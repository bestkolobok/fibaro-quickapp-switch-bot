{"name":"SwitchBot","type":"com.fibaro.genericDevice","apiVersion":"1.3","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_409"},"sections":{"items":[{"components":[{"name":"label_status","style":{"weight":"1.2"},"text":"Status: Ready","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"components":[{"name":"button_test","style":{"weight":"0.50"},"text":"Test Connection","type":"button","visible":true},{"name":"button_search","style":{"weight":"0.50"},"text":"Search devices","type":"button","visible":true}],"style":{"weight":"1.2"},"type":"horizontal"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"select_devices","options":[],"selectionType":"multi","style":{"weight":"1.2"},"text":"Found supported devices:","type":"select","values":[],"visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"button_add","style":{"weight":"1.2"},"text":"Add Selected (0)","type":"button","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"label_ID_9","style":{"weight":"1.2"},"text":"________________________________________","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"label_ID_8","style":{"weight":"1.2"},"text":"Manually forcing pooling","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"button_refresh","style":{"weight":"1.2"},"text":"Refresh All","type":"button","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"label_ID_7","style":{"weight":"1.2"},"text":"________________________________________","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"label_ID_6","style":{"weight":"1.2"},"text":"Webhooks setup (experimental)","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"components":[{"name":"button_wh_setup","style":{"weight":"0.33"},"text":"Setup","type":"button","visible":true},{"name":"button_wh_query","style":{"weight":"0.33"},"text":"Query","type":"button","visible":true},{"name":"button_wh_delete","style":{"weight":"0.33"},"text":"Delete","type":"button","visible":true}],"style":{"weight":"1.2"},"type":"horizontal"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_409"}}},"uiView":[{"components":[{"name":"label_status","style":{"weight":"1.0"},"text":"Status: Ready","type":"label","visible":true}],"style":{"weight":"1.0"},"type":"horizontal"},{"components":[{"eventBinding":{"onLongPressDown":[{"params":{"actionName":"UIAction","args":["onLongPressDown","button_test"]},"type":"deviceAction"}],"onLongPressReleased":[{"params":{"actionName":"UIAction","args":["onLongPressReleased","button_test"]},"type":"deviceAction"}],"onReleased":[{"params":{"actionName":"UIAction","args":["onReleased","button_test"]},"type":"deviceAction"}]},"name":"button_test","style":{"weight":"0.50"},"text":"Test Connection","type":"button","visible":true},{"eventBinding":{"onLongPressDown":[{"params":{"actionName":"UIAction","args":["onLongPressDown","button_search"]},"type":"deviceAction"}],"onLongPressReleased":[{"params":{"actionName":"UIAction","args":["onLongPressReleased","button_search"]},"type":"deviceAction"}],"onReleased":[{"params":{"actionName":"UIAction","args":["onReleased","button_search"]},"type":"deviceAction"}]},"name":"button_search","style":{"weight":"0.50"},"text":"Search devices","type":"button","visible":true}],"style":{"weight":"1.0"},"type":"horizontal"},{"components":[{"eventBinding":{"onToggled":[{"params":{"actionName":"UIAction","args":["onToggled","select_devices","$event.value"]},"type":"deviceAction"}]},"name":"select_devices","options":[],"selectionType":"multi","style":{"weight":"1.0"},"text":"Found supported devices:","type":"select","values":[],"visible":true}],"style":{"weight":"1.0"},"type":"horizontal"},{"components":[{"eventBinding":{"onLongPressDown":[{"params":{"actionName":"UIAction","args":["onLongPressDown","button_add"]},"type":"deviceAction"}],"onLongPressReleased":[{"params":{"actionName":"UIAction","args":["onLongPressReleased","button_add"]},"type":"deviceAction"}],"onReleased":[{"params":{"actionName":"UIAction","args":["onReleased","button_add"]},"type":"deviceAction"}]},"name":"button_add","style":{"weight":"1.0"},"text":"Add Selected (0)","type":"button","visible":true}],"style":{"weight":"1.0"},"type":"horizontal"},{"components":[{"name":"label_ID_9","style":{"weight":"1.0"},"text":"________________________________________","type":"label","visible":true}],"style":{"weight":"1.0"},"type":"horizontal"},{"components":[{"name":"label_ID_8","style":{"weight":"1.0"},"text":"Manually forcing pooling","type":"label","visible":true}],"style":{"weight":"1.0"},"type":"horizontal"},{"components":[{"eventBinding":{"onLongPressDown":[{"params":{"actionName":"UIAction","args":["onLongPressDown","button_refresh"]},"type":"deviceAction"}],"onLongPressReleased":[{"params":{"actionName":"UIAction","args":["onLongPressReleased","button_refresh"]},"type":"deviceAction"}],"onReleased":[{"params":{"actionName":"UIAction","args":["onReleased","button_refresh"]},"type":"deviceAction"}]},"name":"button_refresh","style":{"weight":"1.0"},"text":"Refresh All","type":"button","visible":true}],"style":{"weight":"1.0"},"type":"horizontal"},{"components":[{"name":"label_ID_7","style":{"weight":"1.0"},"text":"________________________________________","type":"label","visible":true}],"style":{"weight":"1.0"},"type":"horizontal"},{"components":[{"name":"label_ID_6","style":{"weight":"1.0"},"text":"Webhooks setup (experimental)","type":"label","visible":true}],"style":{"weight":"1.0"},"type":"horizontal"},{"components":[{"eventBinding":{"onLongPressDown":[{"params":{"actionName":"UIAction","args":["onLongPressDown","button_wh_setup"]},"type":"deviceAction"}],"onLongPressReleased":[{"params":{"actionName":"UIAction","args":["onLongPressReleased","button_wh_setup"]},"type":"deviceAction"}],"onReleased":[{"params":{"actionName":"UIAction","args":["onReleased","button_wh_setup"]},"type":"deviceAction"}]},"name":"button_wh_setup","style":{"weight":"0.33"},"text":"Setup","type":"button","visible":true},{"eventBinding":{"onLongPressDown":[{"params":{"actionName":"UIAction","args":["onLongPressDown","button_wh_query"]},"type":"deviceAction"}],"onLongPressReleased":[{"params":{"actionName":"UIAction","args":["onLongPressReleased","button_wh_query"]},"type":"deviceAction"}],"onReleased":[{"params":{"actionName":"UIAction","args":["onReleased","button_wh_query"]},"type":"deviceAction"}]},"name":"button_wh_query","style":{"weight":"0.33"},"text":"Query","type":"button","visible":true},{"eventBinding":{"onLongPressDown":[{"params":{"actionName":"UIAction","args":["onLongPressDown","button_wh_delete"]},"type":"deviceAction"}],"onLongPressReleased":[{"params":{"actionName":"UIAction","args":["onLongPressReleased","button_wh_delete"]},"type":"deviceAction"}],"onReleased":[{"params":{"actionName":"UIAction","args":["onReleased","button_wh_delete"]},"type":"deviceAction"}]},"name":"button_wh_delete","style":{"weight":"0.33"},"text":"Delete","type":"button","visible":true}],"style":{"weight":"1.0"},"type":"horizontal"}],"useUiView":true,"uiCallbacks":[{"callback":"testConnection","eventType":"onReleased","name":"button_test"},{"callback":"testConnection","eventType":"onLongPressDown","name":"button_test"},{"callback":"","eventType":"onLongPressReleased","name":"button_test"},{"callback":"searchDevices","eventType":"onReleased","name":"button_search"},{"callback":"searchDevices","eventType":"onLongPressDown","name":"button_search"},{"callback":"","eventType":"onLongPressReleased","name":"button_search"},{"callback":"selectDevices","eventType":"onToggled","name":"select_devices"},{"callback":"addSelectedDevices","eventType":"onReleased","name":"button_add"},{"callback":"addSelectedDevices","eventType":"onLongPressDown","name":"button_add"},{"callback":"","eventType":"onLongPressReleased","name":"button_add"},{"callback":"refreshDevices","eventType":"onReleased","name":"button_refresh"},{"callback":"refreshDevices","eventType":"onLongPressDown","name":"button_refresh"},{"callback":"","eventType":"onLongPressReleased","name":"button_refresh"},{"callback":"btnSetupWebhook","eventType":"onReleased","name":"button_wh_setup"},{"callback":"btnSetupWebhook","eventType":"onLongPressDown","name":"button_wh_setup"},{"callback":"","eventType":"onLongPressReleased","name":"button_wh_setup"},{"callback":"btnQueryWebhook","eventType":"onReleased","name":"button_wh_query"},{"callback":"btnQueryWebhook","eventType":"onLongPressDown","name":"button_wh_query"},{"callback":"","eventType":"onLongPressReleased","name":"button_wh_query"},{"callback":"btnDeleteWebhook","eventType":"onReleased","name":"button_wh_delete"},{"callback":"btnDeleteWebhook","eventType":"onLongPressDown","name":"button_wh_delete"},{"callback":"","eventType":"onLongPressReleased","name":"button_wh_delete"}],"quickAppVariables":[{"name":"profile_token","type":"password","value":"********"},{"name":"profile_secret","type":"password","value":"********"},{"name":"dailyRequestCount","type":"string","value":"10"}],"typeTemplateInitialized":true,"userDescription":""},"initialInterfaces":[],"files":[{"name":"main","isMain":true,"isOpen":true,"content":"-- SwitchBot QuickApp for Fibaro HC3\n-- Supports: Curtain, Curtain3, Bot\n-- API: https://github.com/OpenWonderLabs/SwitchBotAPI\n\n--[[\nQUICK APP VARIABLES (Parent):\n- profile_token [string] {REQUIRED} - API token from SwitchBot app\n- profile_secret [string] {REQUIRED} - Secret key from SwitchBot app\n- webhookUrl [string] - http://<your-domain>:<port>/api/callAction\n- webhookEnabled [string] (\"true\" | \"false\")\n\nCHILD DEVICE PROPERTIES:\n- Curtain/Curtain3:\n  - value [number] (0-100) - current position (0=closed, 100=open)\n  - batteryLevel [number] (0-100)\n  \n- Bot:\n  - value [boolean] - current state (on/off)\n  - batteryLevel [number] (0-100)\n]]--\n\nlocal API_HOST = \"https://api.switch-bot.com\"\nlocal API_VERSION = \"v1.1\"\n\nfunction QuickApp:onInit()\n    self:debug(\"=== SwitchBot QuickApp Initializing ===\")\n    \n    -- Initialize API URL\n    self.apiUrl = API_HOST .. \"/\" .. API_VERSION .. \"/\"\n    \n    -- Found devices during search (temporary)\n    self.foundDevices = {}\n    \n    -- Selected devices from UI selector\n    self.selectedDevices = {}\n    \n    -- Initialize smart polling\n    self:initPolling()\n    \n    -- Check credentials\n    local token = self:getVariable(\"profile_token\")\n    local secret = self:getVariable(\"profile_secret\")\n    \n    if not token or token == \"\" or not secret or secret == \"\" then\n        self:warning(\"⚠ API credentials not set!\")\n        self:updateView(\"label_status\", \"text\", \"Status: Credentials missing\")\n        self:debug(\"Set profile_token and profile_secret in QuickApp variables\")\n        return\n    end\n    \n    -- Load existing child devices\n    local childCount = self:loadChildren()\n    self:debug(\"Loaded \" .. childCount .. \" child devices\")\n    \n    -- Print all child devices\n    if childCount > 0 then\n        self:debug(\"Child devices:\")\n        for id, device in pairs(self.childDevices) do\n            self:debug(\"  [\" .. id .. \"] \" .. device.name .. \" (type: \" .. device.type .. \", switchBotId: \" .. tostring(device.switchBotId) .. \")\")\n        end\n        \n        -- Check if webhook is enabled, otherwise use polling\n        local webhookEnabled = self:getVariable(\"webhookEnabled\")\n        if webhookEnabled == \"true\" then\n            self:debug(\"Webhook mode enabled - polling disabled\")\n        else\n            self:debug(\"Starting smart polling...\")\n            self:startPolling()\n        end\n    end\n    \n    self:updateView(\"label_status\", \"text\", \"Status: Ready\")\nend\n\n-- Get child device by SwitchBot ID (simple iteration)\nfunction QuickApp:getDeviceBySwitchBotId(switchBotId)\n    for _, device in pairs(self.childDevices) do\n        if device.switchBotId == switchBotId then\n            return device\n        end\n    end\n    return nil\nend\n\n-- Load existing child devices\nfunction QuickApp:loadChildren()\n    local cdevs = api.get(\"/devices?parentId=\" .. self.id) or {}\n    local count = 0\n    \n    -- Prevent Fibaro from calling initChildDevices after onInit\n    function self:initChildDevices() end\n    \n    for _, child in ipairs(cdevs) do\n        local className = \"QuickAppChild\"\n        local switchBotId = nil\n        \n        -- Find className and switchBotId from quickAppVariables\n        for _, v in ipairs(child.properties.quickAppVariables or {}) do\n            if v.name == \"className\" then\n                className = v.value\n            elseif v.name == \"switchBotId\" then\n                switchBotId = v.value\n            end\n        end\n        \n        -- Create child object with appropriate class\n        local childClass = _G[className] or QuickAppChild\n        local childObject = childClass(child)\n        childObject.switchBotId = switchBotId\n        childObject.parent = self\n        \n        self.childDevices[child.id] = childObject\n        count = count + 1\n    end\n    \n    return count\nend\n\n-- UI Handler: Select devices from dropdown\nfunction QuickApp:selectDevices(event)\n    -- event.values[1] contains array of selected device IDs\n    self.selectedDevices = {}\n    \n    if event.values and event.values[1] then\n        for _, deviceId in ipairs(event.values[1]) do\n            -- Ignore empty placeholder values\n            if deviceId and deviceId ~= \"\" then\n                table.insert(self.selectedDevices, deviceId)\n                self:debug(\"Selected device: \" .. tostring(deviceId))\n            end\n        end\n    end\n    \n    local count = #self.selectedDevices\n    self:updateView(\"button_add\", \"text\", \"Add Selected (\" .. count .. \")\")\nend\n\n-- UI Handler: Add selected devices\nfunction QuickApp:addSelectedDevices()\n    if #self.selectedDevices == 0 then\n        self:debug(\"No devices selected\")\n        return\n    end\n    \n    self:debug(\"Adding \" .. #self.selectedDevices .. \" devices...\")\n    \n    for _, deviceId in ipairs(self.selectedDevices) do\n        local deviceInfo = self.foundDevices[deviceId]\n        if deviceInfo then\n            self:addNewDevice(deviceInfo)\n        else\n            self:debug(\"Device info not found for: \" .. deviceId)\n        end\n    end\n    \n    -- Clear selection\n    self.selectedDevices = {}\n    self:updateView(\"button_add\", \"text\", \"Add Selected (0)\")\n    \n    -- Start polling if not already running\n    self:startPolling()\nend\n\n-- UI Handler: Remove all child devices (for debugging)\nfunction QuickApp:removeAllChildren()\n    self:debug(\"Removing all child devices...\")\n    \n    for id, _ in pairs(self.childDevices) do\n        self:removeChildDevice(id)\n    end\n    \n    self:debug(\"All child devices removed\")\nend"},{"name":"Auth","isMain":false,"isOpen":true,"content":"-- ============================================\n-- SwitchBot API v1.1 Authentication for Fibaro HC3\n-- ============================================\n\nlocal function band(a, b)\n    local result = 0\n    local bitval = 1\n    while a > 0 and b > 0 do\n        if a % 2 == 1 and b % 2 == 1 then\n            result = result + bitval\n        end\n        bitval = bitval * 2\n        a = math.floor(a / 2)\n        b = math.floor(b / 2)\n    end\n    return result\nend\n\nlocal function bor(a, b)\n    local result = 0\n    local bitval = 1\n    while a > 0 or b > 0 do\n        if a % 2 == 1 or b % 2 == 1 then\n            result = result + bitval\n        end\n        bitval = bitval * 2\n        a = math.floor(a / 2)\n        b = math.floor(b / 2)\n    end\n    return result\nend\n\nlocal function bxor(a, b)\n    local result = 0\n    local bitval = 1\n    while a > 0 or b > 0 do\n        if (a % 2) ~= (b % 2) then\n            result = result + bitval\n        end\n        bitval = bitval * 2\n        a = math.floor(a / 2)\n        b = math.floor(b / 2)\n    end\n    return result\nend\n\nlocal function bnot(a)\n    return 0xFFFFFFFF - a\nend\n\nlocal function rshift(a, n)\n    return math.floor(a / (2 ^ n))\nend\n\nlocal function lshift(a, n)\n    return (a * (2 ^ n)) % 0x100000000\nend\n\nlocal function rightrotate(x, n)\n    return bor(rshift(x, n), lshift(x, 32 - n)) % 0x100000000\nend\n\n-- ============================================\n-- SHA256 Implementation\n-- ============================================\n\nlocal function sha256(data)\n    local H = {\n        0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n        0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n    }\n    \n    local K = {\n        0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n        0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n        0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n        0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n        0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n        0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n        0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n        0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n        0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n        0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n        0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n        0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n        0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n        0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n        0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n    }\n    \n    local msg = data\n    local ml = #msg * 8\n    msg = msg .. string.char(0x80)\n    \n    local padding = 64 - ((#msg + 8) % 64)\n    if padding > 0 then\n        msg = msg .. string.rep(string.char(0), padding)\n    end\n    \n    for i = 7, 0, -1 do\n        msg = msg .. string.char(band(rshift(ml, i * 8), 0xFF))\n    end\n    \n    for chunk_start = 1, #msg, 64 do\n        local w = {}\n        \n        for i = 0, 15 do\n            local offset = chunk_start + i * 4\n            w[i] = bor(bor(bor(\n                lshift(string.byte(msg, offset), 24),\n                lshift(string.byte(msg, offset + 1), 16)),\n                lshift(string.byte(msg, offset + 2), 8)),\n                string.byte(msg, offset + 3))\n        end\n        \n        for i = 16, 63 do\n            local s0 = bxor(bxor(rightrotate(w[i-15], 7), rightrotate(w[i-15], 18)), rshift(w[i-15], 3))\n            local s1 = bxor(bxor(rightrotate(w[i-2], 17), rightrotate(w[i-2], 19)), rshift(w[i-2], 10))\n            w[i] = (w[i-16] + s0 + w[i-7] + s1) % 0x100000000\n        end\n        \n        local a, b, c, d, e, f, g, h = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n        \n        for i = 0, 63 do\n            local S1 = bxor(bxor(rightrotate(e, 6), rightrotate(e, 11)), rightrotate(e, 25))\n            local ch = bxor(band(e, f), band(bnot(e), g))\n            local temp1 = (h + S1 + ch + K[i+1] + w[i]) % 0x100000000\n            local S0 = bxor(bxor(rightrotate(a, 2), rightrotate(a, 13)), rightrotate(a, 22))\n            local maj = bxor(bxor(band(a, b), band(a, c)), band(b, c))\n            local temp2 = (S0 + maj) % 0x100000000\n            \n            h = g\n            g = f\n            f = e\n            e = (d + temp1) % 0x100000000\n            d = c\n            c = b\n            b = a\n            a = (temp1 + temp2) % 0x100000000\n        end\n        \n        H[1] = (H[1] + a) % 0x100000000\n        H[2] = (H[2] + b) % 0x100000000\n        H[3] = (H[3] + c) % 0x100000000\n        H[4] = (H[4] + d) % 0x100000000\n        H[5] = (H[5] + e) % 0x100000000\n        H[6] = (H[6] + f) % 0x100000000\n        H[7] = (H[7] + g) % 0x100000000\n        H[8] = (H[8] + h) % 0x100000000\n    end\n    \n    local result = \"\"\n    for i = 1, 8 do\n        for j = 3, 0, -1 do\n            result = result .. string.char(band(rshift(H[i], j * 8), 0xFF))\n        end\n    end\n    \n    return result\nend\n\n-- ============================================\n-- HMAC-SHA256 Implementation\n-- ============================================\n\nlocal function hmac_sha256(key, message)\n    local blocksize = 64\n    \n    if #key > blocksize then\n        key = sha256(key)\n    end\n    \n    if #key < blocksize then\n        key = key .. string.rep(string.char(0), blocksize - #key)\n    end\n    \n    local o_key_pad = \"\"\n    local i_key_pad = \"\"\n    \n    for i = 1, blocksize do\n        local byte = string.byte(key, i)\n        o_key_pad = o_key_pad .. string.char(bxor(byte, 0x5c))\n        i_key_pad = i_key_pad .. string.char(bxor(byte, 0x36))\n    end\n    \n    local inner_hash = sha256(i_key_pad .. message)\n    return sha256(o_key_pad .. inner_hash)\nend\n\n-- ============================================\n-- Base64 Encoding\n-- ============================================\n\nlocal function base64_encode(data)\n    local b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n    local result = {}\n    \n    for i = 1, #data, 3 do\n        local a, b, c = string.byte(data, i, i + 2)\n        b = b or 0\n        c = c or 0\n        \n        local n = lshift(a, 16) + lshift(b, 8) + c\n        \n        table.insert(result, b64chars:sub(band(rshift(n, 18), 63) + 1, band(rshift(n, 18), 63) + 1))\n        table.insert(result, b64chars:sub(band(rshift(n, 12), 63) + 1, band(rshift(n, 12), 63) + 1))\n        table.insert(result, (i + 1 <= #data) and b64chars:sub(band(rshift(n, 6), 63) + 1, band(rshift(n, 6), 63) + 1) or '=')\n        table.insert(result, (i + 2 <= #data) and b64chars:sub(band(n, 63) + 1, band(n, 63) + 1) or '=')\n    end\n    \n    return table.concat(result)\nend\n\n-- ============================================\n-- UUID v4 Generation\n-- ============================================\n\nlocal function generate_uuid()\n    math.randomseed(os.time() + math.random(1000))\n    local template = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'\n    return string.gsub(template, '[xy]', function(c)\n        local v = (c == 'x') and math.random(0, 0xf) or math.random(8, 0xb)\n        return string.format('%x', v)\n    end)\nend\n\n-- ============================================\n-- SwitchBot Authentication\n-- ============================================\n\nlocal function generate_switchbot_auth(token, secret)\n    local nonce = generate_uuid()\n    local t = os.time() * 1000  -- 13-digit timestamp in milliseconds\n    local string_to_sign = token .. tostring(t) .. nonce\n    \n    local hmac = hmac_sha256(secret, string_to_sign)\n    local sign = base64_encode(hmac)\n    \n    return {\n        sign = string.upper(sign),\n        nonce = nonce,\n        t = tostring(t),\n        token = token\n    }\nend\n\n-- Generate authorization headers for SwitchBot API\nfunction QuickApp:getAuthHeaders()\n    local token = self:getVariable(\"profile_token\")\n    local secret = self:getVariable(\"profile_secret\")\n\n    local auth = generate_switchbot_auth(token, secret);\n\n    return {\n        [\"Authorization\"] = auth.token,\n        [\"sign\"] = auth.sign,\n        [\"nonce\"] = auth.nonce,\n        [\"t\"] = auth.t,\n        [\"Content-Type\"] = \"application/json; charset=utf8\"\n    }\nend\n"},{"name":"SearchDevices","isMain":false,"isOpen":true,"content":"-- ============================================\n-- Device Discovery\n-- ============================================\n\n-- Supported device types\nlocal SUPPORTED_DEVICES = {\n    [\"Bot\"] = true,\n    [\"Curtain\"] = true,\n    [\"Curtain3\"] = true,\n    -- Add more supported devices here as needed:\n    -- [\"Plug\"] = true,\n    -- [\"Plug Mini (US)\"] = true,\n    -- [\"Plug Mini (JP)\"] = true,\n}\n\n-- Get human-readable device type name\nlocal function getDeviceTypeName(deviceType)\n    local names = {\n        [\"Curtain\"] = \"Curtain\",\n        [\"Curtain3\"] = \"Curtain 3\",\n        [\"Bot\"] = \"Bot\",\n    }\n    return names[deviceType] or deviceType\nend\n\n-- UI Handler: Search for devices\nfunction QuickApp:searchDevices()\n    self:debug(\"=== DISCOVERING DEVICES ===\")\n    self:updateView(\"label_status\", \"text\", \"Status: Searching...\")\n    \n    -- Clear previous search results\n    self.foundDevices = {}\n    self.selectedDevices = {}\n    \n    -- Reset selector with placeholder\n    self:updateView(\"select_devices\", \"options\", {\n        {text = \"— Searching... —\", type = \"option\", value = \"\"}\n    })\n    self:updateView(\"button_add\", \"text\", \"Add Selected (0)\")\n    \n    self:apiRequest(\"devices\", {\n        method = \"GET\",\n        success = function(body, status)\n            self:processDiscoveredDevices(body)\n        end,\n        error = function(err)\n            self:warning(\"Discovery failed: \" .. tostring(err))\n            self:updateView(\"label_status\", \"text\", \"Status: Discovery failed\")\n        end\n    })\nend\n\n-- Process discovered devices\nfunction QuickApp:processDiscoveredDevices(body)\n    if not body or not body.deviceList then\n        self:debug(\"No devices found\")\n        self:updateView(\"label_status\", \"text\", \"Status: No devices found\")\n        return\n    end\n    \n    local selectorOptions = {}\n    local foundCount = 0\n    local alreadyAddedCount = 0\n    \n    for _, device in ipairs(body.deviceList) do\n        local deviceType = device.deviceType\n        \n        -- Check if device type is supported\n        if SUPPORTED_DEVICES[deviceType] then\n            local deviceId = device.deviceId\n            local deviceName = device.deviceName or \"Unknown\"\n            local isAlreadyAdded = self:isDeviceAlreadyAdded(deviceId)\n            \n            -- Store device info for later use\n            self.foundDevices[deviceId] = {\n                deviceId = deviceId,\n                deviceName = deviceName,\n                deviceType = deviceType,\n                hubDeviceId = device.hubDeviceId,\n                enableCloudService = device.enableCloudService,\n                isAlreadyAdded = isAlreadyAdded\n            }\n            \n            if isAlreadyAdded then\n                alreadyAddedCount = alreadyAddedCount + 1\n                self:debug(\"  [EXISTS] \" .. deviceName .. \" (\" .. deviceType .. \")\")\n            else\n                foundCount = foundCount + 1\n                \n                -- Add to selector options\n                local displayName = deviceName:sub(1, 25) .. \" [\" .. getDeviceTypeName(deviceType) .. \"]\"\n                table.insert(selectorOptions, {\n                    text = displayName,\n                    type = \"option\",\n                    value = deviceId\n                })\n                \n                self:debug(\"  [NEW] \" .. deviceName .. \" (\" .. deviceType .. \")\")\n            end\n        end\n    end\n    \n    -- Also check infrared remote devices if present\n    if body.infraredRemoteList then\n        for _, device in ipairs(body.infraredRemoteList) do\n            self:debug(\"  [IR] \" .. (device.deviceName or \"Unknown\") .. \" (not supported)\")\n        end\n    end\n    \n    -- Update UI\n    if foundCount > 0 then\n        self:updateView(\"select_devices\", \"options\", selectorOptions)\n        self:updateView(\"button_add\", \"text\", \"Add Selected (0)\")\n        self:updateView(\"label_status\", \"text\", \"Status: Found \" .. foundCount .. \" new device(s)\")\n    else\n        -- Clear selector with placeholder\n        self:updateView(\"select_devices\", \"options\", {\n            {text = \"— No devices found —\", type = \"option\", value = \"\"}\n        })\n        \n        if alreadyAddedCount > 0 then\n            self:updateView(\"label_status\", \"text\", \"Status: All \" .. alreadyAddedCount .. \" device(s) already added\")\n        else\n            self:updateView(\"label_status\", \"text\", \"Status: No supported devices found\")\n        end\n    end\n    \n    self:debug(\"━━━━━━━━━━━━━━━━━━━━━\")\n    self:debug(\"Discovery complete:\")\n    self:debug(\"  New devices: \" .. foundCount)\n    self:debug(\"  Already added: \" .. alreadyAddedCount)\n    self:debug(\"━━━━━━━━━━━━━━━━━━━━━\")\nend\n\n-- UI Handler: Test connection / get all devices info\nfunction QuickApp:testConnection()\n    self:debug(\"=== CONNECTION TEST ===\")\n    \n    local token = self:getVariable(\"profile_token\")\n    local secret = self:getVariable(\"profile_secret\")\n    \n    self:debug(\"Token: \" .. (token and token ~= \"\" and \"✓ Set (\" .. token:sub(1, 10) .. \"...)\" or \"✗ Missing\"))\n    self:debug(\"Secret: \" .. (secret and secret ~= \"\" and \"✓ Set\" or \"✗ Missing\"))\n    \n    if not token or token == \"\" or not secret or secret == \"\" then\n        self:updateView(\"label_status\", \"text\", \"Status: Credentials missing\")\n        return\n    end\n    \n    self:updateView(\"label_status\", \"text\", \"Status: Testing connection...\")\n    \n    self:apiRequest(\"devices\", {\n        method = \"GET\",\n        success = function(body, status)\n            local deviceCount = body.deviceList and #body.deviceList or 0\n            self:debug(\"✓ Connection successful! Found \" .. deviceCount .. \" devices in account.\")\n            self:updateView(\"label_status\", \"text\", \"Status: Connected (\" .. deviceCount .. \" devices)\")\n        end,\n        error = function(err)\n            self:debug(\"✗ Connection failed: \" .. tostring(err))\n            self:updateView(\"label_status\", \"text\", \"Status: Connection failed\")\n        end\n    })\nend"},{"name":"CreateDevices","isMain":false,"isOpen":false,"content":"-- ============================================\n-- Child Device Classes\n-- ============================================\n\n-- Curtain device class (works for Curtain and Curtain3)\nclass 'CurtainDevice' (QuickAppChild)\n\nfunction CurtainDevice:__init(device)\n    QuickAppChild.__init(self, device)\n    self.switchBotId = self:getVariable('switchBotId')\n    self.deviceType = self:getVariable('deviceType') or 'Curtain'\nend\n\nfunction CurtainDevice:open()\n    self:debug(\"Opening curtain...\")\n    self:updateProperty(\"value\", 100)\n    self.parent:sendDeviceCommand(self.switchBotId, \"turnOn\", \"default\")\n    self.parent:blockDeviceAndSchedulePoll(self.switchBotId)\nend\n\nfunction CurtainDevice:close()\n    self:debug(\"Closing curtain...\")\n    self:updateProperty(\"value\", 0)\n    self.parent:sendDeviceCommand(self.switchBotId, \"turnOff\", \"default\")\n    self.parent:blockDeviceAndSchedulePoll(self.switchBotId)\nend\n\nfunction CurtainDevice:stop()\n    self:debug(\"Stopping curtain...\")\n    -- SwitchBot doesn't have native pause, so we get current position and set it\n    self.parent:getDeviceStatus(self.switchBotId, function(status)\n        if status and status.slidePosition then\n            local position = tonumber(status.slidePosition)\n            self.parent:sendDeviceCommand(self.switchBotId, \"setPosition\", \"0,ff,\" .. tostring(position))\n        end\n    end)\nend\n\n-- Value: 0-100 (Fibaro convention: 0=closed, 100=open)\nfunction CurtainDevice:setValue(value)\n    self:debug(\"Setting curtain position to: \" .. tostring(value))\n    -- SwitchBot uses inverted scale: 0=open, 100=closed\n    local switchBotPosition = 100 - value\n    self:updateProperty(\"value\", value)\n    self.parent:sendDeviceCommand(self.switchBotId, \"setPosition\", \"0,ff,\" .. tostring(switchBotPosition))\n    self.parent:blockDeviceAndSchedulePoll(self.switchBotId)\nend\n\n-- Alias for compatibility\nfunction CurtainDevice:setPosition(value)\n    self:setValue(value)\nend\n\n\n-- Bot device class\nclass 'BotDevice' (QuickAppChild)\n\nfunction BotDevice:__init(device)\n    QuickAppChild.__init(self, device)\n    self.switchBotId = self:getVariable('switchBotId')\n    self.deviceType = self:getVariable('deviceType') or 'Bot'\nend\n\nfunction BotDevice:turnOn()\n    self:debug(\"Turning Bot ON...\")\n    self:updateProperty(\"value\", true)\n    self.parent:sendDeviceCommand(self.switchBotId, \"turnOn\", \"default\")\n    self.parent:blockDeviceAndSchedulePoll(self.switchBotId)\nend\n\nfunction BotDevice:turnOff()\n    self:debug(\"Turning Bot OFF...\")\n    self:updateProperty(\"value\", false)\n    self.parent:sendDeviceCommand(self.switchBotId, \"turnOff\", \"default\")\n    self.parent:blockDeviceAndSchedulePoll(self.switchBotId)\nend\n\nfunction BotDevice:press()\n    self:debug(\"Pressing Bot...\")\n    self.parent:sendDeviceCommand(self.switchBotId, \"press\", \"default\")\n    self.parent:blockDeviceAndSchedulePoll(self.switchBotId)\nend\n\n-- Toggle state\nfunction BotDevice:toggle()\n    local currentValue = self.properties.value\n    if currentValue then\n        self:turnOff()\n    else\n        self:turnOn()\n    end\nend\n\n\n-- ============================================\n-- Device Creation\n-- ============================================\n\n-- Device type configuration\nlocal DEVICE_CONFIG = {\n    [\"Curtain\"] = {\n        fibaroType = \"com.fibaro.rollerShutter\",\n        className = \"CurtainDevice\",\n        interfaces = {\"battery\"},\n        properties = {\n            value = 0\n        }\n    },\n    [\"Curtain3\"] = {\n        fibaroType = \"com.fibaro.rollerShutter\",\n        className = \"CurtainDevice\",\n        interfaces = {\"battery\"},\n        properties = {\n            value = 0\n        }\n    },\n    [\"Bot\"] = {\n        fibaroType = \"com.fibaro.binarySwitch\",\n        className = \"BotDevice\",\n        interfaces = {\"battery\"},\n        properties = {\n            value = false\n        }\n    }\n}\n\n-- Check if device is already added\nfunction QuickApp:isDeviceAlreadyAdded(switchBotId)\n    for _, device in pairs(self.childDevices) do\n        if device.switchBotId == switchBotId then\n            return true\n        end\n    end\n    return false\nend\n\n-- Add new device\nfunction QuickApp:addNewDevice(deviceInfo)\n    local switchBotId = deviceInfo.deviceId\n    local deviceType = deviceInfo.deviceType\n    local deviceName = deviceInfo.deviceName\n    \n    -- Check if already exists\n    if self:isDeviceAlreadyAdded(switchBotId) then\n        self:debug(\"Device already added: \" .. deviceName .. \" (\" .. switchBotId .. \")\")\n        return nil\n    end\n    \n    -- Get device configuration\n    local config = DEVICE_CONFIG[deviceType]\n    if not config then\n        self:warning(\"Unsupported device type: \" .. deviceType)\n        return nil\n    end\n    \n    self:debug(\"Adding device: \" .. deviceName .. \" (type: \" .. deviceType .. \")\")\n    \n    -- Prepare variables for child device (className is added separately in createChild)\n    local variables = {\n        switchBotId = switchBotId,\n        deviceType = deviceType\n    }\n    \n    -- Create child device\n    local child = self:createChild(\n        deviceName,\n        config.fibaroType,\n        config.className,\n        variables,\n        config.properties,\n        config.interfaces\n    )\n    \n    if child then\n        self:debug(\"✓ Device added successfully: \" .. deviceName .. \" [ID: \" .. child.id .. \"]\")\n        \n        -- Get initial state\n        self:updateDeviceState(switchBotId)\n        \n        return child\n    else\n        self:warning(\"✗ Failed to create device: \" .. deviceName)\n        return nil\n    end\nend\n\n-- Create child device helper\nfunction QuickApp:createChild(name, fibaroType, className, variables, properties, interfaces)\n    properties = properties or {}\n    interfaces = interfaces or {}\n    \n    -- Prepare quickAppVariables\n    properties.quickAppVariables = properties.quickAppVariables or {}\n    \n    -- Add className first (important for loadChildren)\n    table.insert(properties.quickAppVariables, 1, {name = \"className\", value = className})\n    \n    -- Add other variables\n    for varName, varValue in pairs(variables or {}) do\n        table.insert(properties.quickAppVariables, {name = varName, value = varValue})\n    end\n    \n    -- Create child device\n    local child = self:createChildDevice({\n        name = name,\n        type = fibaroType,\n        initialProperties = properties,\n        initialInterfaces = interfaces\n    }, _G[className])\n    \n    if child then\n        child.switchBotId = variables.switchBotId\n    end\n    \n    return child\nend"},{"name":"Pooling","isMain":false,"isOpen":true,"content":"-- ============================================\n-- Smart Polling & State Synchronization\n-- ============================================\n\n--[[\nSwitchBot API Limit: 10,000 requests/day (~7/min)\n\nSmart Polling Strategy:\n- IDLE mode: 5 min interval (normal state)  \n- SLEEP mode: 15 min interval (night)\n- After command: block updates for 30 sec, then single poll\n- Rate limit protection with daily counter\n]]--\n\n-- Polling modes\nlocal POLL_MODE = {\n    IDLE = \"idle\",       -- Normal state\n    SLEEP = \"sleep\"      -- Low activity / night\n}\n\n-- Intervals in seconds\nlocal POLL_INTERVALS = {\n    [POLL_MODE.IDLE] = 300,      -- 5 minutes\n    [POLL_MODE.SLEEP] = 900      -- 15 minutes\n}\n\n-- Block duration after command (seconds)\nlocal COMMAND_BLOCK_DURATION = 30\n\n-- Daily request limit (with safety margin)\nlocal DAILY_REQUEST_LIMIT = 9500  -- Keep 500 for manual actions\n\n-- ============================================\n-- Polling State Management\n-- ============================================\n\nfunction QuickApp:initPolling()\n    self.polling = {\n        active = false,\n        mode = POLL_MODE.IDLE,\n        timer = nil,\n        \n        -- Rate limiting\n        requestCount = 0,\n        requestCountDate = os.date(\"%Y-%m-%d\"),\n        \n        -- Per-device update blocking (deviceId -> unblock timestamp)\n        deviceBlockedUntil = {}\n    }\n    \n    -- Load saved request count\n    local savedCount = tonumber(self:getVariable(\"dailyRequestCount\")) or 0\n    local savedDate = self:getVariable(\"dailyRequestDate\") or \"\"\n    \n    if savedDate == os.date(\"%Y-%m-%d\") then\n        self.polling.requestCount = savedCount\n    end\nend\n\n-- Check and update rate limit\nfunction QuickApp:checkRateLimit()\n    local today = os.date(\"%Y-%m-%d\")\n    \n    -- Reset counter on new day\n    if self.polling.requestCountDate ~= today then\n        self.polling.requestCount = 0\n        self.polling.requestCountDate = today\n        self:setVariable(\"dailyRequestDate\", today)\n    end\n    \n    -- Check if limit exceeded\n    if self.polling.requestCount >= DAILY_REQUEST_LIMIT then\n        self:warning(\"Daily API limit reached! Polling paused until tomorrow.\")\n        return false\n    end\n    \n    return true\nend\n\n-- Increment request counter\nfunction QuickApp:incrementRequestCount()\n    self.polling.requestCount = self.polling.requestCount + 1\n    \n    -- Save every 10 requests\n    if self.polling.requestCount % 10 == 0 then\n        self:setVariable(\"dailyRequestCount\", tostring(self.polling.requestCount))\n    end\nend\n\n-- Get current polling mode\nfunction QuickApp:getPollingMode()\n    -- Check time for sleep mode (23:00 - 07:00)\n    local hour = tonumber(os.date(\"%H\"))\n    if hour >= 23 or hour < 7 then\n        return POLL_MODE.SLEEP\n    end\n    \n    return POLL_MODE.IDLE\nend\n\n-- Check if device updates are blocked\nfunction QuickApp:isDeviceBlocked(switchBotId)\n    if not self.polling then return false end\n    \n    local blockedUntil = self.polling.deviceBlockedUntil[switchBotId]\n    if blockedUntil and os.time() < blockedUntil then\n        return true\n    end\n    \n    return false\nend\n\n-- Block device updates and schedule delayed poll (called after sending command)\nfunction QuickApp:blockDeviceAndSchedulePoll(switchBotId)\n    if not self.polling then\n        self:initPolling()\n    end\n    \n    local now = os.time()\n    self.polling.deviceBlockedUntil[switchBotId] = now + COMMAND_BLOCK_DURATION\n    \n    self:debug(\"Device \" .. switchBotId .. \" updates blocked for \" .. COMMAND_BLOCK_DURATION .. \" sec\")\n    \n    -- Schedule single poll after block expires\n    setTimeout(function()\n        self:debug(\"Block expired, polling device: \" .. switchBotId)\n        self.polling.deviceBlockedUntil[switchBotId] = nil\n        self:updateDeviceState(switchBotId)\n    end, COMMAND_BLOCK_DURATION * 1000)\nend\n\n-- ============================================\n-- Polling Control\n-- ============================================\n\nfunction QuickApp:startPolling()\n    if not self.polling then\n        self:initPolling()\n    end\n    \n    if self.polling.active then\n        self:debug(\"Polling already active\")\n        return\n    end\n    \n    self.polling.active = true\n    self:debug(\"Smart polling started\")\n    \n    -- Initial poll\n    self:pollAllDevices()\n    \n    -- Schedule next\n    self:scheduleNextPoll()\nend\n\nfunction QuickApp:stopPolling()\n    if not self.polling then return end\n    \n    self.polling.active = false\n    \n    if self.polling.timer then\n        clearTimeout(self.polling.timer)\n        self.polling.timer = nil\n    end\n    \n    self:debug(\"Polling stopped\")\nend\n\nfunction QuickApp:scheduleNextPoll()\n    if not self.polling or not self.polling.active then return end\n    \n    -- Clear existing timer\n    if self.polling.timer then\n        clearTimeout(self.polling.timer)\n    end\n    \n    local mode = self:getPollingMode()\n    local interval = POLL_INTERVALS[mode]\n    \n    self.polling.mode = mode\n    \n    self.polling.timer = setTimeout(function()\n        if self.polling.active then\n            self:pollAllDevices()\n            self:scheduleNextPoll()\n        end\n    end, interval * 1000)\n    \n    self:trace(\"Next poll in \" .. math.floor(interval / 60) .. \" min (\" .. mode .. \" mode)\")\nend\n\n-- ============================================\n-- Device Polling\n-- ============================================\n\nfunction QuickApp:pollAllDevices()\n    -- Check rate limit\n    if not self:checkRateLimit() then\n        return\n    end\n    \n    local devicesToPoll = {}\n    \n    -- Collect devices to poll (skip blocked ones)\n    for id, device in pairs(self.childDevices) do\n        if device.switchBotId then\n            if not self:isDeviceBlocked(device.switchBotId) then\n                table.insert(devicesToPoll, device.switchBotId)\n            else\n                self:trace(\"Skipping blocked device: \" .. device.switchBotId)\n            end\n        end\n    end\n    \n    if #devicesToPoll == 0 then\n        return\n    end\n    \n    local mode = self:getPollingMode()\n    self:trace(\"Polling \" .. #devicesToPoll .. \" device(s) [\" .. mode .. \" mode, \" .. self.polling.requestCount .. \" requests today]\")\n    \n    -- Poll with small delays between requests\n    for i, switchBotId in ipairs(devicesToPoll) do\n        setTimeout(function()\n            self:updateDeviceState(switchBotId)\n        end, (i - 1) * 200)  -- 200ms between requests\n    end\nend\n\n-- Update single device state\nfunction QuickApp:updateDeviceState(switchBotId)\n    local device = self:getDeviceBySwitchBotId(switchBotId)\n    if not device then return end\n    \n    -- Double-check device is not blocked\n    if self:isDeviceBlocked(switchBotId) then\n        self:trace(\"Device \" .. switchBotId .. \" is blocked, skipping update\")\n        return\n    end\n    \n    self:getDeviceStatus(switchBotId, function(status)\n        if status then\n            self:applyDeviceStatus(device, status)\n        end\n    end)\n    \n    -- Count the request\n    self:incrementRequestCount()\nend\n\n-- Apply status to device based on device type\nfunction QuickApp:applyDeviceStatus(device, status)\n    local deviceType = device:getVariable('deviceType') or 'Unknown'\n    \n    -- Update battery level (common for all battery-powered devices)\n    if status.battery ~= nil then\n        local batteryLevel = tonumber(status.battery)\n        if batteryLevel then\n            device:updateProperty(\"batteryLevel\", batteryLevel)\n        end\n    end\n    \n    -- Device-specific status handling\n    if deviceType == \"Curtain\" or deviceType == \"Curtain3\" then\n        self:applyCurtainStatus(device, status)\n    elseif deviceType == \"Bot\" then\n        self:applyBotStatus(device, status)\n    else\n        self:debug(\"Unknown device type for status update: \" .. deviceType)\n    end\nend\n\n-- Apply Curtain status\nfunction QuickApp:applyCurtainStatus(device, status)\n    -- slidePosition: 0 = fully open, 100 = fully closed (SwitchBot convention)\n    -- Fibaro convention: 0 = closed, 100 = open\n    if status.slidePosition ~= nil then\n        local switchBotPosition = tonumber(status.slidePosition)\n        if switchBotPosition then\n            local fibaroValue = 100 - switchBotPosition\n            device:updateProperty(\"value\", fibaroValue)\n        end\n    end\n    \n    -- Moving status\n    if status.moving ~= nil then\n        device:updateProperty(\"moving\", status.moving)\n    end\n    \n    -- Calibration status\n    if status.calibrate ~= nil then\n        local isCalibrated = status.calibrate == true\n        device:updateProperty(\"calibrated\", isCalibrated)\n    end\nend\n\n-- Apply Bot status\nfunction QuickApp:applyBotStatus(device, status)\n    -- power: \"on\" or \"off\"\n    if status.power ~= nil then\n        local isOn = status.power == \"on\"\n        device:updateProperty(\"value\", isOn)\n    end\nend\n\n-- ============================================\n-- Manual Controls\n-- ============================================\n\n-- Force immediate poll of all devices (ignores blocks)\nfunction QuickApp:refreshDevices()\n    self:debug(\"Manual refresh triggered\")\n    \n    -- Clear all blocks\n    if self.polling then\n        self.polling.deviceBlockedUntil = {}\n    end\n    \n    self:pollAllDevices()\nend\n\n-- Get polling stats\nfunction QuickApp:getPollingStats()\n    if not self.polling then\n        return \"Polling not initialized\"\n    end\n    \n    local mode = self:getPollingMode()\n    local interval = POLL_INTERVALS[mode]\n    \n    return string.format(\n        \"Mode: %s, Interval: %ds, Requests today: %d/%d\",\n        mode,\n        interval,\n        self.polling.requestCount,\n        DAILY_REQUEST_LIMIT\n    )\nend\n\n-- UI: Show polling stats\nfunction QuickApp:btnPollingStats()\n    local stats = self:getPollingStats()\n    self:debug(stats)\n    self:updateView(\"label_status\", \"text\", stats)\nend"},{"name":"Http","isMain":false,"isOpen":true,"content":"-- Generic API request\nfunction QuickApp:apiRequest(path, options)\n    options = options or {}\n    \n    local headers = self:getAuthHeaders()\n    if not headers then\n        if options.error then\n            options.error(\"Authentication failed - credentials missing\")\n        end\n        return\n    end\n    \n    local url = self.apiUrl .. path\n    local method = options.method or \"GET\"\n    local requestBody = options.data and json.encode(options.data) or nil\n    \n    local http = net.HTTPClient({timeout = 10000})\n    \n    http:request(url, {\n        options = {\n            method = method,\n            data = requestBody,\n            headers = headers\n        },\n        success = function(response)\n            if not response.data then\n                if options.error then\n                    options.error(\"No response data\")\n                end\n                return\n            end\n            \n            local success, result = pcall(json.decode, response.data)\n            if not success then\n                if options.error then\n                    options.error(\"JSON parse error: \" .. tostring(result))\n                end\n                return\n            end\n            \n            if result.statusCode == 100 then\n                if options.success then\n                    options.success(result.body, response.status)\n                end\n            else\n                local errorMsg = result.message or \"Unknown error (code: \" .. tostring(result.statusCode) .. \")\"\n                self:debug(\"API error: \" .. errorMsg)\n                if options.error then\n                    options.error(errorMsg)\n                end\n            end\n        end,\n        error = function(err)\n            self:debug(\"HTTP error: \" .. tostring(err))\n            if options.error then\n                options.error(err)\n            end\n        end\n    })\nend\n\n-- Send command to device\nfunction QuickApp:sendDeviceCommand(deviceId, command, parameter)\n    self:debug(\"Sending command: \" .. command .. \" to device: \" .. deviceId)\n    \n    local path = \"devices/\" .. deviceId .. \"/commands\"\n    \n    self:apiRequest(path, {\n        method = \"POST\",\n        data = {\n            command = command,\n            parameter = parameter or \"default\",\n            commandType = \"command\"\n        },\n        success = function(body, status)\n            self:debug(\"✓ Command sent successfully\")\n        end,\n        error = function(err)\n            self:warning(\"✗ Command failed: \" .. tostring(err))\n        end\n    })\nend\n\n-- Get device status\nfunction QuickApp:getDeviceStatus(deviceId, callback)\n    local path = \"devices/\" .. deviceId .. \"/status\"\n    \n    self:apiRequest(path, {\n        method = \"GET\",\n        success = function(body, status)\n            if callback then\n                callback(body)\n            end\n        end,\n        error = function(err)\n            self:debug(\"Failed to get device status: \" .. tostring(err))\n            if callback then\n                callback(nil)\n            end\n        end\n    })\nend\n"},{"name":"Webhook","isMain":false,"isOpen":false,"content":"-- ============================================\n-- Webhook Configuration & Handling\n-- ============================================\n\n--[[\nSwitchBot Webhook documentation:\nhttps://github.com/OpenWonderLabs/SwitchBotAPI#webhook\n\nTo use webhooks, your Fibaro HC3 must be accessible from the internet.\nOptions:\n1. Port forwarding on router + DDNS\n2. Cloudflare Tunnel\n3. ngrok\n4. Proxy server (Node.js, Cloudflare Worker, etc.)\n\nWebhook URL format for Fibaro HC3:\nPOST http://<HC3_EXTERNAL_URL>/api/callAction\nBody: {\"deviceId\": <QuickAppID>, \"name\": \"handleWebhook\", \"args\": [<webhook_data>]}\n\nOr with proxy that converts SwitchBot format to Fibaro API call.\n]]--\n\n-- ============================================\n-- Webhook Setup Functions\n-- ============================================\n\n-- Setup webhook in SwitchBot cloud\n-- webhookUrl: URL where SwitchBot will send updates (must be accessible from internet)\nfunction QuickApp:setupWebhook(webhookUrl)\n    if not webhookUrl or webhookUrl == \"\" then\n        webhookUrl = self:getVariable(\"webhookUrl\")\n    end\n    \n    if not webhookUrl or webhookUrl == \"\" then\n        self:warning(\"Webhook URL not set! Set 'webhookUrl' variable first.\")\n        self:updateView(\"label_status\", \"text\", \"Status: Webhook URL missing\")\n        return\n    end\n    \n    self:debug(\"Setting up webhook: \" .. webhookUrl)\n    self:updateView(\"label_status\", \"text\", \"Status: Setting up webhook...\")\n    \n    self:apiRequest(\"webhook/setupWebhook\", {\n        method = \"POST\",\n        data = {\n            action = \"setupWebhook\",\n            url = webhookUrl,\n            deviceList = \"ALL\"\n        },\n        success = function(body, status)\n            self:debug(\"✓ Webhook setup successful\")\n            self:setVariable(\"webhookUrl\", webhookUrl)\n            self:setVariable(\"webhookEnabled\", \"true\")\n            self:updateView(\"label_status\", \"text\", \"Status: Webhook active\")\n            \n            -- Stop polling if webhook is active\n            self:stopPolling()\n        end,\n        error = function(err)\n            self:warning(\"✗ Webhook setup failed: \" .. tostring(err))\n            self:updateView(\"label_status\", \"text\", \"Status: Webhook setup failed\")\n        end\n    })\nend\n\n-- Query current webhook configuration\nfunction QuickApp:queryWebhook()\n    self:debug(\"Querying webhook configuration...\")\n    \n    self:apiRequest(\"webhook/queryWebhook\", {\n        method = \"POST\",\n        data = {\n            action = \"queryUrl\"\n        },\n        success = function(body, status)\n            if body and body.urls then\n                self:debug(\"Current webhook URLs:\")\n                for i, url in ipairs(body.urls) do\n                    self:debug(\"  \" .. i .. \": \" .. url)\n                end\n                \n                if #body.urls > 0 then\n                    self:updateView(\"label_status\", \"text\", \"Status: Webhook configured\")\n                else\n                    self:updateView(\"label_status\", \"text\", \"Status: No webhook configured\")\n                end\n            else\n                self:debug(\"No webhooks configured\")\n                self:updateView(\"label_status\", \"text\", \"Status: No webhook configured\")\n            end\n        end,\n        error = function(err)\n            self:warning(\"Query webhook failed: \" .. tostring(err))\n        end\n    })\nend\n\n-- Delete webhook\nfunction QuickApp:deleteWebhook(webhookUrl)\n    if not webhookUrl or webhookUrl == \"\" then\n        webhookUrl = self:getVariable(\"webhookUrl\")\n    end\n    \n    if not webhookUrl or webhookUrl == \"\" then\n        self:warning(\"No webhook URL to delete\")\n        return\n    end\n    \n    self:debug(\"Deleting webhook: \" .. webhookUrl)\n    \n    self:apiRequest(\"webhook/deleteWebhook\", {\n        method = \"POST\",\n        data = {\n            action = \"deleteWebhook\",\n            url = webhookUrl\n        },\n        success = function(body, status)\n            self:debug(\"✓ Webhook deleted\")\n            self:setVariable(\"webhookEnabled\", \"false\")\n            self:updateView(\"label_status\", \"text\", \"Status: Webhook removed\")\n            \n            -- Restart polling as fallback\n            self:startPolling()\n        end,\n        error = function(err)\n            self:warning(\"Delete webhook failed: \" .. tostring(err))\n        end\n    })\nend\n\n-- ============================================\n-- Webhook Handler\n-- ============================================\n\n--[[\nSwitchBot webhook payload format:\n{\n    \"eventType\": \"changeReport\",\n    \"eventVersion\": \"1\",\n    \"context\": {\n        \"deviceType\": \"Curtain3\",\n        \"deviceMac\": \"F3DE1D6C45B5\",\n        \"timeOfSample\": 1698765432,\n        \"slidePosition\": 50,\n        \"battery\": 85,\n        ...\n    }\n}\n\nTo call this from external service:\nPOST http://<HC3_IP>/api/callAction\nHeaders: \n  Authorization: Basic <base64(admin:password)>\n  Content-Type: application/json\nBody:\n{\n    \"deviceId\": <QuickAppID>,\n    \"name\": \"handleWebhook\",\n    \"args\": [<webhook_payload_as_string_or_object>]\n}\n]]--\n\n-- Handle incoming webhook from SwitchBot (called via Fibaro API)\nfunction QuickApp:handleWebhook(payload)\n    self:debug(\"Webhook received!\")\n    \n    -- Parse payload if it's a string\n    local data = payload\n    if type(payload) == \"string\" then\n        local success, parsed = pcall(json.decode, payload)\n        if success then\n            data = parsed\n        else\n            self:warning(\"Failed to parse webhook payload\")\n            return\n        end\n    end\n    \n    -- Validate payload\n    if not data or type(data) ~= \"table\" then\n        self:warning(\"Invalid webhook payload\")\n        return\n    end\n    \n    self:trace(\"Webhook data: \" .. json.encode(data))\n    \n    -- Handle different event types\n    local eventType = data.eventType\n    \n    if eventType == \"changeReport\" then\n        self:handleChangeReport(data.context)\n    else\n        self:debug(\"Unknown event type: \" .. tostring(eventType))\n    end\nend\n\n-- Handle changeReport event\nfunction QuickApp:handleChangeReport(context)\n    if not context then\n        self:warning(\"No context in changeReport\")\n        return\n    end\n    \n    local deviceMac = context.deviceMac\n    local deviceType = context.deviceType\n    \n    if not deviceMac then\n        self:warning(\"No deviceMac in webhook context\")\n        return\n    end\n    \n    self:debug(\"Change report for device: \" .. deviceMac .. \" (\" .. tostring(deviceType) .. \")\")\n    \n    -- Find device by MAC (SwitchBot deviceId is MAC without colons)\n    local device = self:getDeviceBySwitchBotId(deviceMac)\n    \n    if not device then\n        self:debug(\"Device not found for MAC: \" .. deviceMac)\n        return\n    end\n    \n    -- Apply status based on device type\n    if deviceType == \"Curtain\" or deviceType == \"Curtain3\" or deviceType == \"WoCurtain\" then\n        self:applyWebhookCurtainStatus(device, context)\n    elseif deviceType == \"Bot\" or deviceType == \"WoHand\" then\n        self:applyWebhookBotStatus(device, context)\n    else\n        self:debug(\"Unhandled device type in webhook: \" .. tostring(deviceType))\n    end\nend\n\n-- Apply Curtain status from webhook\nfunction QuickApp:applyWebhookCurtainStatus(device, context)\n    -- slidePosition: 0 = open, 100 = closed (SwitchBot)\n    -- Fibaro: 0 = closed, 100 = open\n    if context.slidePosition ~= nil then\n        local switchBotPosition = tonumber(context.slidePosition)\n        if switchBotPosition then\n            local fibaroValue = 100 - switchBotPosition\n            device:updateProperty(\"value\", fibaroValue)\n            self:debug(\"Updated curtain position: \" .. fibaroValue .. \"%\")\n        end\n    end\n    \n    -- Battery\n    if context.battery ~= nil then\n        local battery = tonumber(context.battery)\n        if battery then\n            device:updateProperty(\"batteryLevel\", battery)\n        end\n    end\n    \n    -- Calibration\n    if context.calibrate ~= nil then\n        device:updateProperty(\"calibrated\", context.calibrate)\n    end\nend\n\n-- Apply Bot status from webhook\nfunction QuickApp:applyWebhookBotStatus(device, context)\n    -- power: \"on\" or \"off\"\n    if context.power ~= nil then\n        local isOn = context.power == \"on\"\n        device:updateProperty(\"value\", isOn)\n        self:debug(\"Updated bot state: \" .. tostring(isOn))\n    end\n    \n    -- Battery\n    if context.battery ~= nil then\n        local battery = tonumber(context.battery)\n        if battery then\n            device:updateProperty(\"batteryLevel\", battery)\n        end\n    end\nend\n\n-- ============================================\n-- UI Handlers for Webhook\n-- ============================================\n\n-- UI: Setup webhook button\nfunction QuickApp:btnSetupWebhook()\n    local url = self:getVariable(\"webhookUrl\")\n    if url and url ~= \"\" then\n        self:setupWebhook(url)\n    else\n        self:warning(\"Set 'webhookUrl' variable in QuickApp settings first\")\n        self:updateView(\"label_status\", \"text\", \"Status: Set webhookUrl variable\")\n    end\nend\n\n-- UI: Query webhook button  \nfunction QuickApp:btnQueryWebhook()\n    self:queryWebhook()\nend\n\n-- UI: Delete webhook button\nfunction QuickApp:btnDeleteWebhook()\n    self:deleteWebhook()\nend"}]}